1.1 将序列分解为单独的变量
q：现在有一个包含 N 个元素的元组或者是序列，将它分解为 N 个变量。
运用赋值。不仅仅只是元组或列表，只要对象是可迭代的，就可以执行分解操作。 包括字符串，文件对象，迭代器和生成器。
只想解压一部分，丢弃其他的值。可以使用任意变量名去占位，到时候丢掉这些变量就行了。最多使用，_
>>> data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
>>> _, shares, price, _ = data
>>> shares
50
>>> price
91.1
>>>

1.2 解压可迭代对象赋值给多个变量
q：从任意可迭代对象中解压出 N 个元素出来（可迭代对象的元素个数超过N）。
运用“*表达式”。
星号表达式在迭代元素为可变长元组的序列时是很有用的，如下例所示：
#records是一个元祖
records = [
    ('foo', 1, 2),
    ('bar', 'hello'),
    ('foo', 3, 4),
]
#定义函数
def do_foo(x, y):
    print('foo', x, y)
def do_bar(s):
    print('bar', s)
#注意这里的tag, *args分别代表什么
for tag, *args in records:
    if tag == 'foo':
        do_foo(*args)
    elif tag == 'bar':
        do_bar(*args)

1.3 保留最后 N 个元素
q：在迭代操作或者其他操作的时候，只保留最后有限几个元素的历史记录。
#从collections模块导入deque，collections容器，deque队列（类似于列表容器）
from collections import deque
#定义函数，注意这里deque和yield
def search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)#deque(maxlen=N)创建了一个固定长度的队列，当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。
    for line in lines:
        if pattern in line:
            yield line, previous_lines#yield类似于return，返回一个值，并记住这个返回的位置，下次迭代就从这个位置开始。函数有了yield语句就会转变成一个生成器。
        previous_lines.append(line)
# Example use on a file
if __name__ == '__main__':#__name__是当前模块名，当模块被直接运行时模块名为 __main__ 。 当模块被直接运行时，if 以下代码块将被运行，当模块是被导入时，代码块不被运行。
    with open(r'../../cookbook/somefile.txt') as f:
        for line, prevlines in search(f, 'python', 5):
            for pline in prevlines:
                print(pline, end='')
            print(line, end='')
            print('-' * 20)

如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。
q = deque()
q.append(1)
q.appendleft(4)
q.pop()
q.popleft()

1.4 查找最大或最小的 N 个元素
q：从一个集合中获得最大或者最小的 N 个元素列表。
运用heapq 模块有两个函数：nlargest() 和 nsmallest() 
portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])#参数"3"代表N，"portfolio"代表列表，接受参数key，用于dict或其他数据结构类型使用
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])

heap.heapify(list)可以转换列表成为堆结构。堆数据结构最重要的特征是heap[0]永远是最小的元素。剩余的元素可以很容易的通过调用 heapq.heappop() 方法得到， 
该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 O(log N)，N 是堆大小）。 
比如，如果想要查找最小的 3 个元素，heapq.heappop(heap)使用3次。

找最大最小值方法总结：
1.当要查找的元素个数相对比较小的时候，函数 nlargest() 和 nsmallest() 是很合适的
2.仅想查找唯一的最小或最大（N=1）的元素的话，那么使用 min() 和 max() 函数会更快些
3.如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点( sorted(items)[:N] 或者是 sorted(items)[-N:] )

1.5 实现一个优先级队列
#定义类，class后面可加可不加()，如果继承类的时候，一定要加括号并填父类名。
import heapq
class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0
    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item)) #括号里括的是元祖！heappush(heap,item)往堆里添加新值，"heap"是堆，"item"为新值
        self._index += 1 #改变__init()__中的index的大小
    def pop(self):
        return heapq.heappop(self._queue)[-1] #索引为最后位置处的值
class Item:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'Item({!r})'.format(self.name) #format()方法格式化指定的值，并将其插入字符串的占位符内。
q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)
q.pop()
q.pop()
q.pop()
q.pop()

1.6 字典中的键映射多个值
q：实现一个键对应多个值的字典（一键多值字典[multidict]）
d = {
    'a' : [1, 2, 3],
    'b' : [4, 5]
}
e = {
    'a' : {1, 2, 3},
    'b' : {4, 5}
}
或是使用collections模块中的defaultdict来构造这样的字典。
defaultdict的一个特征是它会自动初始化每个key刚开始对应的值，所以只需要关注添加元素操作。
from collections import defaultdict
d = defaultdict(list)#列表
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)
d = defaultdict(set)#集合
d['a'].add(1)
d['a'].add(2)
d['b'].add(4)

一般来讲，创建一个多值映射字典是很简单的。但是，如果你选择自己实现的话，那么对于值的初始化可能会有点麻烦， 你可能会像下面这样来实现：
d = {}
for key, value in pairs:
    if key not in d:
        d[key] = []
    d[key].append(value)
如果使用 defaultdict 的话代码就更加简洁了：
d = defaultdict(list)
for key, value in pairs:
    d[key].append(value)

1.7 字典排序
q：创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。
使用 collections 模块中的 OrderedDict 类，在迭代操作的时候它会保持元素被插入时的顺序
from collections import OrderedDict
d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4
# Outputs "foo 1", "bar 2", "spam 3", "grok 4"
for key in d:
    print(key, d[key])
OrderedDict 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。
缺点：一个 OrderedDict 的大小是一个普通字典的两倍

1.8 字典的运算
q：在数据字典中执行一些计算操作（比如求最小值、最大值、排序等等）。
使用 zip() 函数先将键和值反转过来，再用sorted() 函数来排列字典数据。
prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}

#求最大最小键-值对
min_price = min(zip(prices.values(), prices.keys()))
# min_price is (10.75, 'FB')
max_price = max(zip(prices.values(), prices.keys()))
# max_price is (612.78, 'AAPL')

#排序
prices_sorted = sorted(zip(prices.values(), prices.keys()))
# prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),
#                   (45.23, 'ACME'), (205.55, 'IBM'),
#                   (612.78, 'AAPL')]

需要注意的是 zip() 函数创建的是一个只能访问一次的迭代器。
比如，下面的代码就会产生错误：
prices_and_names = zip(prices.values(), prices.keys())
print(min(prices_and_names)) # OK
print(max(prices_and_names)) # ValueError: max() arg is an empty sequence # 第二次访问就不行了

在字典上进行值的运算：
min(prices.values()) # Returns 10.75
max(prices.values()) # Returns 612.78
可以在 min() 和 max() 函数中提供 key 函数参数来获取最小值或最大值对应的键的信息。比如：
min(prices, key=lambda k: prices[k]) # Returns 'FB' #输出键
max(prices, key=lambda k: prices[k]) # Returns 'AAPL' #输出键
min_value = prices[min(prices, key=lambda k: prices[k])] #输出值

1.9 查找两字典的相同点
q：在两个字典中寻寻找相同点（比如相同的键、相同的值等等）。
在两字典的 keys() 或者 items() 方法返回结果上执行集合操作
a = {
    'x' : 1,
    'y' : 2,
    'z' : 3
}
b = {
    'w' : 10,
    'x' : 11,
    'y' : 2
}
a.keys() & b.keys() # { 'x', 'y' } # 找相同的键
a.keys() - b.keys() # { 'z' } # 查找a中不在b中的键
a.items() & b.items() # { ('y', 2) } # 找相同的键-值对

这些操作也可以用于修改或者过滤字典元素。
比如以现有字典构造一个排除几个指定键的新字典：
c = {key:a[key] for key in (a.keys() - {'z', 'w'}) }
# c is {'x': 1, 'y': 2}

总结： 
字典的 keys() 方法返回一个展现键集合的键视图对象，字典的 items() 方法返回一个包含 (键，值) 对的元素视图对象。都支持集合操作。
字典的 values() 方法也是类似，但不支持集合操作，因为值视图不能保证所有的值互不相同，这样会导致某些集合操作会出现问题。

1.10 删除序列重复元素并保持顺序
q：在一个序列上消除重复的值同时保持元素顺序不变。
如果序列上的值都是可哈希的（hashable）类型，那么可以很简单的利用集合或者生成器来解决这个问题。
def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)
如果在不可哈希（比如 dict 类型）的对象序列中去除重复元素，则修改上述代码为：
def dedupe(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item) #将序列中的元素转换为可哈希的类型
        if val not in seen:
            yield item
            seen.add(val)
用法示例：
>>> a = [ {'x':1, 'y':2}, {'x':1, 'y':3}, {'x':1, 'y':2}, {'x':2, 'y':4}]
>>> list(dedupe(a, key=lambda d: (d['x'],d['y']))) #d: (d['x'],d['y'])，两个值，x和y的值
[{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]
>>> list(dedupe(a, key=lambda d: d['x'])) #d: d['x']，一个值，x的值
[{'x': 1, 'y': 2}, {'x': 2, 'y': 4}]

如果仅消除重复元素，可简单的构造一个集合，但不能维护元素的顺序。
>>> a
[1, 5, 2, 1, 9, 1, 5, 10]
>>> set(a)
{1, 2, 10, 5, 9}

构造的dedupe()函数不仅局限于列表处理。比如对文本文件处理：
with open(somefile,'r') as f:
for line in dedupe(f):
    ...

1.11 命名切片
q：如果程序包含了大量硬编码切片索引（eg：record[20:23]），需清理一下代码。
从一个记录（比如文件或其他类似格式）中的某些固定位置提取字段：
record = '....................100 .......513.25 ..........'
cost = int(record[20:23]) * float(record[31:37])
更好的方式：
SHARES = slice(20, 23)
PRICE = slice(31, 37)
cost = int(record[SHARES]) * float(record[PRICE])

一个切片对象a，你可以分别调用它的 a.start , a.stop , a.step 属性来获取更多的信息
>>> a = slice(5, 50, 2)
>>> a.start
5
>>> a.stop
50
>>> a.step
2
>>>
另外，你还可以通过调用切片的 indices(size) 方法将它映射到一个已知大小的序列上。 这个方法返回一个三元组 (start, stop, step)
>>> s = 'HelloWorld'
>>> a.indices(len(s)) #a.indices(10)
(5, 10, 2)
>>> for i in range(*a.indices(len(s))): #这里的用法值得学，但是没找到解释！！！
...     print(s[i]) #i=5,7,9
...
W
r
d
>>>





