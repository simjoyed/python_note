1.1 将序列分解为单独的变量
q：现在有一个包含 N 个元素的元组或者是序列，将它分解为 N 个变量。
运用赋值。不仅仅只是元组或列表，只要对象是可迭代的，就可以执行分解操作。 包括字符串，文件对象，迭代器和生成器。
只想解压一部分，丢弃其他的值。可以使用任意变量名去占位，到时候丢掉这些变量就行了。最多使用，_
>>> data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
>>> _, shares, price, _ = data
>>> shares
50
>>> price
91.1
>>>

1.2 解压可迭代对象赋值给多个变量
q：从任意可迭代对象中解压出 N 个元素出来（可迭代对象的元素个数超过N）。
运用“*表达式”。
星号表达式在迭代元素为可变长元组的序列时是很有用的，如下例所示：
#records是一个元祖
records = [
    ('foo', 1, 2),
    ('bar', 'hello'),
    ('foo', 3, 4),
]
#定义函数
def do_foo(x, y):
    print('foo', x, y)
def do_bar(s):
    print('bar', s)
#注意这里的tag, *args分别代表什么
for tag, *args in records:
    if tag == 'foo':
        do_foo(*args)
    elif tag == 'bar':
        do_bar(*args)

1.3 保留最后 N 个元素
q：在迭代操作或者其他操作的时候，只保留最后有限几个元素的历史记录。
#从collections模块导入deque，collections容器，deque队列（类似于列表容器）
from collections import deque
#定义函数，注意这里deque和yield
def search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)#deque(maxlen=N)创建了一个固定长度的队列，当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。
    for line in lines:
        if pattern in line:
            yield line, previous_lines#yield类似于return，返回一个值，并记住这个返回的位置，下次迭代就从这个位置开始。函数有了yield语句就会转变成一个生成器。
        previous_lines.append(line)
# Example use on a file
if __name__ == '__main__':#__name__是当前模块名，当模块被直接运行时模块名为 __main__ 。 当模块被直接运行时，if 以下代码块将被运行，当模块是被导入时，代码块不被运行。
    with open(r'../../cookbook/somefile.txt') as f:
        for line, prevlines in search(f, 'python', 5):
            for pline in prevlines:
                print(pline, end='')
            print(line, end='')
            print('-' * 20)

如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。
q = deque()
q.append(1)
q.appendleft(4)
q.pop()
q.popleft()

1.4 查找最大或最小的 N 个元素
q：从一个集合中获得最大或者最小的 N 个元素列表。
运用heapq 模块有两个函数：nlargest() 和 nsmallest() 
portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])#参数"3"代表N，"portfolio"代表列表，接受参数key，用于dict或其他数据结构类型使用
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])

heap.heapify(list)可以转换列表成为堆结构。堆数据结构最重要的特征是heap[0]永远是最小的元素。剩余的元素可以很容易的通过调用 heapq.heappop() 方法得到， 
该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 O(log N)，N 是堆大小）。 
比如，如果想要查找最小的 3 个元素，heapq.heappop(heap)使用3次。

找最大最小值方法总结：
1.当要查找的元素个数相对比较小的时候，函数 nlargest() 和 nsmallest() 是很合适的
2.仅想查找唯一的最小或最大（N=1）的元素的话，那么使用 min() 和 max() 函数会更快些
3.如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点( sorted(items)[:N] 或者是 sorted(items)[-N:] )

1.5 实现一个优先级队列
#定义类，class后面可加可不加()，如果继承类的时候，一定要加括号并填父类名。
import heapq
class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0
    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item)) #括号里括的是元祖！heappush(heap,item)往堆里添加新值，"heap"是堆，"item"为新值
        self._index += 1 #改变__init()__中的index的大小
    def pop(self):
        return heapq.heappop(self._queue)[-1] #索引为最后位置处的值
class Item:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'Item({!r})'.format(self.name) #format()方法格式化指定的值，并将其插入字符串的占位符内。
q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)
q.pop()
q.pop()
q.pop()
q.pop()

1.6 字典中的键映射多个值
q：实现一个键对应多个值的字典（一键多值字典[multidict]）
d = {
    'a' : [1, 2, 3],
    'b' : [4, 5]
}
e = {
    'a' : {1, 2, 3},
    'b' : {4, 5}
}
或是使用collections模块中的defaultdict来构造这样的字典。
defaultdict的一个特征是它会自动初始化每个key刚开始对应的值，所以只需要关注添加元素操作。
from collections import defaultdict
d = defaultdict(list)#列表
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)
d = defaultdict(set)#集合
d['a'].add(1)
d['a'].add(2)
d['b'].add(4)

一般来讲，创建一个多值映射字典是很简单的。但是，如果你选择自己实现的话，那么对于值的初始化可能会有点麻烦， 你可能会像下面这样来实现：
d = {}
for key, value in pairs:
    if key not in d:
        d[key] = []
    d[key].append(value)
如果使用 defaultdict 的话代码就更加简洁了：
d = defaultdict(list)
for key, value in pairs:
    d[key].append(value)

1.7 字典排序
q：创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。
使用 collections 模块中的 OrderedDict 类，在迭代操作的时候它会保持元素被插入时的顺序
from collections import OrderedDict
d = OrderedDict()
d['foo'] = 1
d['bar'] = 2
d['spam'] = 3
d['grok'] = 4
# Outputs "foo 1", "bar 2", "spam 3", "grok 4"
for key in d:
    print(key, d[key])
OrderedDict 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。
缺点：一个 OrderedDict 的大小是一个普通字典的两倍

1.8 字典的运算
q：在数据字典中执行一些计算操作（比如求最小值、最大值、排序等等）。
使用 zip() 函数先将键和值反转过来，再用sorted() 函数来排列字典数据。
prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}

#求最大最小键-值对
min_price = min(zip(prices.values(), prices.keys()))
# min_price is (10.75, 'FB')
max_price = max(zip(prices.values(), prices.keys()))
# max_price is (612.78, 'AAPL')

#排序
prices_sorted = sorted(zip(prices.values(), prices.keys()))
# prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),
#                   (45.23, 'ACME'), (205.55, 'IBM'),
#                   (612.78, 'AAPL')]

需要注意的是 zip() 函数创建的是一个只能访问一次的迭代器。
比如，下面的代码就会产生错误：
prices_and_names = zip(prices.values(), prices.keys())
print(min(prices_and_names)) # OK
print(max(prices_and_names)) # ValueError: max() arg is an empty sequence # 第二次访问就不行了

在字典上进行值的运算：
min(prices.values()) # Returns 10.75
max(prices.values()) # Returns 612.78
可以在 min() 和 max() 函数中提供 key 函数参数来获取最小值或最大值对应的键的信息。比如：
min(prices, key=lambda k: prices[k]) # Returns 'FB' #输出键
max(prices, key=lambda k: prices[k]) # Returns 'AAPL' #输出键
min_value = prices[min(prices, key=lambda k: prices[k])] #输出值

1.9 查找两字典的相同点
q：在两个字典中寻寻找相同点（比如相同的键、相同的值等等）。
在两字典的 keys() 或者 items() 方法返回结果上执行集合操作
a = {
    'x' : 1,
    'y' : 2,
    'z' : 3
}
b = {
    'w' : 10,
    'x' : 11,
    'y' : 2
}
a.keys() & b.keys() # { 'x', 'y' } # 找相同的键
a.keys() - b.keys() # { 'z' } # 查找a中不在b中的键
a.items() & b.items() # { ('y', 2) } # 找相同的键-值对

这些操作也可以用于修改或者过滤字典元素。
比如以现有字典构造一个排除几个指定键的新字典：
c = {key:a[key] for key in (a.keys() - {'z', 'w'}) }
# c is {'x': 1, 'y': 2}

总结： 
字典的 keys() 方法返回一个展现键集合的键视图对象，字典的 items() 方法返回一个包含 (键，值) 对的元素视图对象。都支持集合操作。
字典的 values() 方法也是类似，但不支持集合操作，因为值视图不能保证所有的值互不相同，这样会导致某些集合操作会出现问题。

1.10 删除序列重复元素并保持顺序
q：在一个序列上消除重复的值同时保持元素顺序不变。
如果序列上的值都是可哈希的（hashable）类型，那么可以很简单的利用集合或者生成器来解决这个问题。
def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)
如果在不可哈希（比如 dict 类型）的对象序列中去除重复元素，则修改上述代码为：
def dedupe(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item) #将序列中的元素转换为可哈希的类型
        if val not in seen:
            yield item
            seen.add(val)
用法示例：
>>> a = [ {'x':1, 'y':2}, {'x':1, 'y':3}, {'x':1, 'y':2}, {'x':2, 'y':4}]
>>> list(dedupe(a, key=lambda d: (d['x'],d['y']))) #d: (d['x'],d['y'])，两个值，x和y的值
[{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]
>>> list(dedupe(a, key=lambda d: d['x'])) #d: d['x']，一个值，x的值
[{'x': 1, 'y': 2}, {'x': 2, 'y': 4}]

如果仅消除重复元素，可简单的构造一个集合，但不能维护元素的顺序。
>>> a
[1, 5, 2, 1, 9, 1, 5, 10]
>>> set(a)
{1, 2, 10, 5, 9}

构造的dedupe()函数不仅局限于列表处理。比如对文本文件处理：
with open(somefile,'r') as f:
for line in dedupe(f):
    ...

1.11 命名切片
q：如果程序包含了大量硬编码切片索引（eg：record[20:23]），需清理一下代码。
从一个记录（比如文件或其他类似格式）中的某些固定位置提取字段：
record = '....................100 .......513.25 ..........'
cost = int(record[20:23]) * float(record[31:37])
更好的方式：
SHARES = slice(20, 23)
PRICE = slice(31, 37)
cost = int(record[SHARES]) * float(record[PRICE])

一个切片对象a，你可以分别调用它的 a.start , a.stop , a.step 属性来获取更多的信息
>>> a = slice(5, 50, 2)
>>> a.start
5
>>> a.stop
50
>>> a.step
2
>>>
另外，你还可以通过调用切片的 indices(size) 方法将它映射到一个已知大小的序列上。 这个方法返回一个三元组 (start, stop, step)
>>> s = 'HelloWorld'
>>> a.indices(len(s)) #a.indices(10)
(5, 10, 2)
>>> for i in range(*a.indices(len(s))): #这里的用法值得学，但是没找到解释！！！
...     print(s[i]) #i=5,7,9
...
W
r
d
>>>

1.12 序列中出现次数最多的元素
q：找出一个序列中出现次数最多的元素。
collections模块中的Counter类就是专门为这类问题而设计的，它有一个有用的most_common()方法直接给了答案。
words = [
    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
    'eyes', "don't", 'look', 'around', 'the', 'eyes', 'look', 'into',
    'my', 'eyes', "you're", 'under'
]
from collections import Counter #导入Counter类，counter：计数器
word_counts = Counter(words) 
# 出现频率最高的3个单词
top_three = word_counts.most_common(3)
print(top_three)
# Outputs [('eyes', 8), ('the', 5), ('look', 4)]

Counter对象可以接受任意的由可哈希（hashable）元素构成的序列对象作为输入。
一个 Counter 对象就是一个字典，将元素映射到它出现的次数上。
>>> word_counts['not']
1
>>> word_counts['eyes']
8
>>>

使用 update() 方法增加计数
>>> word_counts.update(morewords)
>>>

Counter 实例一个鲜为人知的特性是它们可以很容易的跟数学运算操作相结合。
>>> a = Counter(words)
>>> b = Counter(morewords)
>>> a
Counter({'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2,
"you're": 1, "don't": 1, 'under': 1, 'not': 1})
>>> b
Counter({'eyes': 1, 'looking': 1, 'are': 1, 'in': 1, 'not': 1, 'you': 1,
'my': 1, 'why': 1})
>>> # Combine counts 增加计数
>>> c = a + b
>>> c
Counter({'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2,
'around': 2, "you're": 1, "don't": 1, 'in': 1, 'why': 1,
'looking': 1, 'are': 1, 'under': 1, 'you': 1})
>>> # Subtract counts 减少计数
>>> d = a - b
>>> d
Counter({'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2,
"you're": 1, "don't": 1, 'under': 1})
>>>

1.13 通过某个关键字排序一个字典列表
q：有一个字典列表，根据某个或某几个字典字段来排序这个列表。
使用 operator 模块的 itemgetter 函数，可以非常容易的排序这样的数据结构。
比如说如下字典列表：
rows = [
    {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
    {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
    {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
    {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]

from operator import itemgetter
rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))
print(rows_by_fname)
print(rows_by_uid)
#itemgetter() 函数也支持多个 keys，比如下面的代码
rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))
print(rows_by_lfname)

sorted()函数接受字典列表和一个关键字参数key，这个参数应该代表一个可调用对象（callable），这个对象通过key=itemgetter()来实现。
itemgetter() 有时候也可以用 lambda 表达式代替，比如：
rows_by_fname = sorted(rows, key=lambda r: r['fname'])
rows_by_lfname = sorted(rows, key=lambda r: (r['lname'],r['fname']))
上述内容同样适用于 min() 和 max() 等函数。
min(rows, key=itemgetter('uid'))
max(rows, key=itemgetter('uid'))

1.14 排序不支持原生比较的对象
q：排序类型相同的对象，但是他们不支持原生的比较操作。
依然运用sorted()函数，关键字key部分用key=attrgetter()
如果你在应用程序里面有一个 User 实例序列，并且你希望通过他们的 user_id 属性进行排序， 你可以提供一个以 User 实例作为输入并输出对应 user_id 值的 callable 对象。比如：
class User:
    def __init__(self, user_id):
        self.user_id = user_id
    def __repr__(self):
        return 'User({})'.format(self.user_id) #格式化函数，不管输入是字符还是数字
def sort_notcompare():
    users = [User(23), User(3), User(99)]
    print(users)
    print(sorted(users, key=lambda u: u.user_id)) #可以用lambda表达式
另外一种方式是使用 operator.attrgetter() 来代替 lambda 函数：
>>> from operator import attrgetter
>>> sorted(users, key=attrgetter('user_id'))
[User(3), User(23), User(99)]
>>>

与itemgetter()类似，itemgetter()也可进行如下排序操作：
by_name = sorted(users, key=attrgetter('last_name', 'first_name'))
min(users, key=attrgetter('user_id'))
max(users, key=attrgetter('user_id'))

1.15 通过某个字段将记录分组
q：有一个字典或者实例的序列，然后你想根据某个特定的字段（比如说date）来分组迭代访问。
itertools.groupby() 函数对于这样的数据分组操作非常实用。 #groupby 分组依据
rows = [
    {'address': '5412 N CLARK', 'date': '07/01/2012'},
    {'address': '5148 N CLARK', 'date': '07/04/2012'},
    {'address': '5800 E 58TH', 'date': '07/02/2012'},
    {'address': '2122 N CLARK', 'date': '07/03/2012'},
    {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
    {'address': '1060 W ADDISON', 'date': '07/02/2012'},
    {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
    {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]

from operator import itemgetter
from itertools import groupby
#首先需要按照指定的字段(这里是date)排序
rows.sort(key=itemgetter('date')) 
#然后调用 itertools.groupby() 函数
for date, items in groupby(rows, key=itemgetter('date')): 
    print(date)
    for i in items:
        print(' ', i)
输出的结果：
07/01/2012
  {'date': '07/01/2012', 'address': '5412 N CLARK'}
  {'date': '07/01/2012', 'address': '4801 N BROADWAY'}
07/02/2012
  {'date': '07/02/2012', 'address': '5800 E 58TH'}
  {'date': '07/02/2012', 'address': '5645 N RAVENSWOOD'}
  {'date': '07/02/2012', 'address': '1060 W ADDISON'}
07/03/2012
  {'date': '07/03/2012', 'address': '2122 N CLARK'}
07/04/2012
  {'date': '07/04/2012', 'address': '5148 N CLARK'}
  {'date': '07/04/2012', 'address': '1039 W GRANVILLE'}

注意：groupby()函数扫描整个序列并且查找连续相同值（或者根据指定 key 函数返回值相同）的元素序列，并将它们分组。 
在每次迭代时，groupby()创建一个迭代器，并在每次迭代时返回一个值（value）和一个子迭代器（sub_iterator），这个子迭代器可以生成产生所有在该分组内具有该值的项。
因此，准备步骤要根据指定的字段将数据排序。因为 groupby() 仅仅检查连续的元素。

除此在外，无需排序，可以使用 defaultdict() 来构建一个多值字典（前面1.6 小节）。
from collections import defaultdict
rows_by_date = defaultdict(list) #构建一个一键多值字典
for row in rows:
    rows_by_date[row['date']].append(row) #往里面增加内容

>>> for r in rows_by_date['07/01/2012']: #访问每个日期的记录
... print(r)
...
{'date': '07/01/2012', 'address': '5412 N CLARK'}
{'date': '07/01/2012', 'address': '4801 N BROADWAY'}
>>>

1.16 筛选序列元素
q：一个数据序列，利用一些规则从中提取出需要的值或者是删减序列
最简单最直接的方式：列表推导式和生成器表达式
1.列表推导式
>>> mylist = [1, 4, -5, 10, -7, 2, 3, -1]
>>> [n for n in mylist if n > 0]
[1, 4, 10, 2, 3]
>>> [n for n in mylist if n < 0]
[-5, -7, -1]
>>>

如果输出结果非常多的话，可以使用生成器表达式产生筛选的结果。
2.生成器表达式
>>> pos = (n for n in mylist if n > 0)
>>> pos
<generator object <genexpr> at 0x1006a0eb0>
>>> for x in pos:
... print(x)

过滤规则比较复杂时，可以先将处理筛选逻辑的代码放到单独的函数中，再使用内建的filter()函数处理
values = ['1', '2', '-3', '-', '4', 'N/A', '5']
#构造函数，数字时返回Ture，出错时返回False
def is_int(val):
    try:
        x = int(val)
        return True
    except ValueError:
        return False
#filter(function,iterable)函数，过滤掉不符合条件的元素，返回符合条件的新元素
ivals = list(filter(is_int, values)) #需要列表形式的结果，加上list()
print(ivals)
# Outputs ['1', '2', '-3', '4', '5']

数据转换（运算）：
>>> mylist = [1, 4, -5, 10, -7, 2, 3, -1]
>>> import math
>>> [math.sqrt(n) for n in mylist if n > 0] #运用计算函数，转换数据
[1.0, 2.0, 3.1622776601683795, 1.4142135623730951, 1.7320508075688772]
>>>

替换新值：
>>> clip_neg = [n if n > 0 else 0 for n in mylist] #注意表达式顺序
>>> clip_neg
[1, 4, 0, 10, 0, 2, 3, 0]
>>> clip_pos = [n if n < 0 else 0 for n in mylist] 
>>> clip_pos
[0, 0, -5, 0, -7, 0, 0, -1]
>>>

需要用另外一个相关联的序列来过滤某个序列的时候，可以使用itertools.compress()，它以一个 iterable 对象和一个相对应的 Boolean 选择器序列作为输入参数
addresses = [
    '5412 N CLARK',
    '5148 N CLARK',
    '5800 E 58TH',
    '2122 N CLARK',
    '5645 N RAVENSWOOD',
    '1060 W ADDISON',
    '4801 N BROADWAY',
    '1039 W GRANVILLE',
]
counts = [ 0, 3, 10, 4, 1, 7, 6, 1]

>>> from itertools import compress
>>> more5 = [n > 5 for n in counts]
>>> more5
[False, False, True, False, False, True, True, False] #布尔序列
>>> list(compress(addresses, more5)) #compress()
['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY']
>>>

1.17 从字典中提取子集
q：构造一个字典，它是另外一个字典的子集。
利用字典推导式（dictionary comprehension）。
prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
# 构造字典推导式 {key: value 推导式} 
p1 = {key: value for key, value in prices.items() if value > 200} 
tech_names = {'AAPL', 'IBM', 'HPQ', 'MSFT'}
p2 = {key: value for key, value in prices.items() if key in tech_names}

方法二：创建元组序列，再传递给dict()函数
p1 = dict((key, value) for key, value in prices.items() if value > 200)
或是写成：
tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
p2 = { key:prices[key] for key in prices.keys() & tech_names }

运行速度上，字典推导式最快且更清晰。

1.18 映射名称到序列元素
q：想通过名称来访问元素。
使用collections.namedtuple()函数返回python标准元组类型的子类。
>>> from collections import namedtuple #导入namedtuple，tuple：元组
>>> Subscriber = namedtuple('Subscriber', ['addr', 'joined']) #构造元组类型
>>> sub = Subscriber('jonesy@example.com', '2012-10-19') #返回元组实例
>>> sub
Subscriber(addr='jonesy@example.com', joined='2012-10-19')
>>> sub.addr
'jonesy@example.com'
>>> sub.joined
'2012-10-19'
>>>

namedtuple的实例与普通的元组是可互换的，而且支持所有普通元组所支持的操作，例如索引（indexing）和分解（unpacking）
>>> len(sub) #索引
2
>>> addr, joined = sub #分解
>>> addr
'jonesy@example.com'
>>> joined
'2012-10-19'
>>>

为什么需要将名称映射到序列的元素中？因为通过元素的位置来访问数据，假如在表单中新增了一列数据，则无法访问原有的数据。
因此，首先将返回的元组转型未命名元组，则可解决这一问题。
#原有的代码：
def compute_cost(records):
    total = 0.0
    for rec in records:
        total += rec[1] * rec[2] #计算总的市值和
    return total
    
#使用命名元组的代码：
from collections import namedtuple 
Stock = namedtuple('Stock', ['name', 'shares', 'price']) #构造命名元组
def compute_cost(records):
    total = 0.0 #0.0 保留一位小数？
    for rec in records: 
        s = Stock(*rec) #将列表拆分成一个个的独立元素，不加*，会将整个列表当做一个元素使用（rec是个列表）。*args：接收若干个位置参数，转换成元组tuple形式
        total += s.shares * s.price
    return total

注意：namedtuple是不可变的（immutable）
from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price'])
def compute_cost(records):
    total = 0.0
    for rec in records:
        s = Stock(*rec)
        total += s.shares * s.price
    return total

如需改变，需使用namedtuple实例的_replace()方法。
>>> s = s._replace(shares=75)
>>> s
Stock(name='ACME', shares=75, price=123.45)
>>>

_replace通常用来：创建一个包含默认值的“原形”元组，使用_replace()方法创建一个新的实例，把相应的值替换掉
from collections import namedtuple

Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time']) #构造命名元组

# Create a prototype instance
stock_prototype = Stock('', 0, 0.0, None, None) #“原形”元组

# Function to convert a dictionary to a Stock #将字典转化为元组
def dict_to_stock(s):
    return stock_prototype._replace(**s) #双**，与上面的单*一样，为了拆分成一个个的独立元素，因为这里的s是字典，用双*。**kwargs：接收若干个关键字参数，转换成字典dict形式

>>> a = {'name': 'ACME', 'shares': 100, 'price': 123.45}
>>> dict_to_stock(a)
Stock(name='ACME', shares=100, price=123.45, date=None, time=None) #输出元组
>>> b = {'name': 'ACME', 'shares': 100, 'price': 123.45, 'date': '12/17/2012'}
>>> dict_to_stock(b)
Stock(name='ACME', shares=100, price=123.45, date='12/17/2012', time=None)
>>>

8.4节中会考虑定义一个高效的数据结构，可以方便的修改各种实例属性：使用__slots__属性的类。（slots，插槽）

1.19 转换并同时计算数据
q：在数据进行计算时，需先对数据做转换或筛选。
运用生成器表达式。
nums = [1, 2, 3, 4, 5]
s = sum(x * x for x in nums) #计算平方和

更多的例子：
# Determine if any .py files exist in a directory 确定目录中是否存在.py文件
import os #导入os模块，操作系统模块
files = os.listdir('dirname')
if any(name.endswith('.py') for name in files): #any()函数，判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True。
    print('There be python!')
else:
    print('Sorry, no python.')
    
# Output a tuple as CSV #将元组输出为CSV
s = ('ACME', 50, 123.45) #s为元组
print(','.join(str(x) for x in s)) #join()方法用于将序列中的元素以指定的字符连接生成一个新的字符串。这里以“,”连接。

# Data reduction across fields of a data structure #跨数据结构字段的数据简化
portfolio = [
    {'name':'GOOG', 'shares': 50},
    {'name':'YHOO', 'shares': 75},
    {'name':'AOL', 'shares': 20},
    {'name':'SCOX', 'shares': 65}
]
min_shares = min(s['shares'] for s in portfolio) #针对字典也可以

 比如，在上面的portfolio（证券）例子中，可以考虑下面的替代方案：
# Original: Returns 20
min_shares = min(s['shares'] for s in portfolio)
# Alternative: Returns {'name': 'AOL', 'shares': 20}
min_shares = min(portfolio, key=lambda s: s['shares']) #替代方案

1.20 合并多个字典或映射
q：有多个字典或映射，想在逻辑上将它们合并为一个单独的映射结构，并执行某些特定的操作，比如查找值或检查键是否存在。
运用collections模块中的ChainMap类来解决。
如有两个字典：
a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }

from collections import ChainMap
c = ChainMap(a,b) #合并
print(c['x']) # Outputs 1 (from a)
print(c['y']) # Outputs 2 (from b)
print(c['z']) # Outputs 3 (from a)

ChainMap接受多个映射然后在逻辑上使它们表现为一个单独的映射结构，这些映射并不是真的合并在一起了，
ChainMap类在内部建立了一个容纳这些映射关系的列表，并重新定义常见的字典操作来遍历这个列表。

>>> len(c)
3
>>> list(c.keys())
['x', 'y', 'z']
>>> list(c.values())
[1, 2, 3]
>>>
有重复的键，第一次出现的映射值会被返回。例子程序中的 c['z'] 总是会返回字典 a 中对应的值，而不是 b 中对应的值。

对于字典的更新或删除操作总是影响的是列表中第一个字典。比如：
>>> c['z'] = 10
>>> c['w'] = 40
>>> del c['x']
>>> a
{'w': 40, 'z': 10}
>>> del c['y']
Traceback (most recent call last):
...
KeyError: "Key not found in the first mapping: 'y'"
>>>

ChainMap对于编程语言中的作用范围变量（比如 globals全局变量, locals局部变量等）是非常有用的。 
有一些方法可以使它变得简单：
>>> values = ChainMap()
>>> values['x'] = 1
>>> # Add a new mapping 增加一个新的映射
>>> values = values.new_child()
>>> values['x'] = 2
>>> # Add a new mapping
>>> values = values.new_child()
>>> values['x'] = 3
>>> values
ChainMap({'x': 3}, {'x': 2}, {'x': 1})
>>> values['x']
3
>>> # Discard last mapping 丢弃最后的映射
>>> values = values.parents
>>> values['x']
2
>>> # Discard last mapping
>>> values = values.parents
>>> values['x']
1
>>> values
ChainMap({'x': 1})
>>>

ChainMap的替代方案，利用字典的updata()方法将多个字典合并在一起。
>>> a = {'x': 1, 'z': 3 }
>>> b = {'y': 2, 'z': 4 }
>>> merged = dict(b)
>>> merged.update(a)
>>> merged['x']
1
>>> merged['y']
2
>>> merged['z']
3
>>>

两者区别：updata()破坏了原始数据。
>>> a['x'] = 13
>>> merged['x']
1
ChainMap 使用原来的字典，它自己不创建新的字典。所以它并不会产生上面所说的结果
>>> a = {'x': 1, 'z': 3 }
>>> b = {'y': 2, 'z': 4 }
>>> merged = ChainMap(a, b)
>>> merged['x']
1
>>> a['x'] = 42
>>> merged['x'] # Notice change to merged dicts
42
>>>
