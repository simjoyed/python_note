1.1 将序列分解为单独的变量
q：现在有一个包含 N 个元素的元组或者是序列，将它分解为 N 个变量。
运用赋值。不仅仅只是元组或列表，只要对象是可迭代的，就可以执行分解操作。 包括字符串，文件对象，迭代器和生成器。
只想解压一部分，丢弃其他的值。可以使用任意变量名去占位，到时候丢掉这些变量就行了。最多使用，_
>>> data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
>>> _, shares, price, _ = data
>>> shares
50
>>> price
91.1
>>>

1.2 解压可迭代对象赋值给多个变量
q：从任意可迭代对象中解压出 N 个元素出来（可迭代对象的元素个数超过N）。
运用“*表达式”。
星号表达式在迭代元素为可变长元组的序列时是很有用的，如下例所示：
#records是一个元祖
records = [
    ('foo', 1, 2),
    ('bar', 'hello'),
    ('foo', 3, 4),
]
#定义函数
def do_foo(x, y):
    print('foo', x, y)
def do_bar(s):
    print('bar', s)
#注意这里的tag, *args分别代表什么
for tag, *args in records:
    if tag == 'foo':
        do_foo(*args)
    elif tag == 'bar':
        do_bar(*args)

1.3 保留最后 N 个元素
q：在迭代操作或者其他操作的时候，只保留最后有限几个元素的历史记录。
#从collections模块导入deque，collections容器，deque队列（类似于列表容器）
from collections import deque
#定义函数，注意这里deque和yield
def search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)#deque(maxlen=N)创建了一个固定长度的队列，当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。
    for line in lines:
        if pattern in line:
            yield line, previous_lines#yield类似于return，返回一个值，并记住这个返回的位置，下次迭代就从这个位置开始。函数有了yield语句就会转变成一个生成器。
        previous_lines.append(line)
# Example use on a file
if __name__ == '__main__':#__name__是当前模块名，当模块被直接运行时模块名为 __main__ 。 当模块被直接运行时，if 以下代码块将被运行，当模块是被导入时，代码块不被运行。
    with open(r'../../cookbook/somefile.txt') as f:
        for line, prevlines in search(f, 'python', 5):
            for pline in prevlines:
                print(pline, end='')
            print(line, end='')
            print('-' * 20)

如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。
q = deque()
q.append(1)
q.appendleft(4)
q.pop()
q.popleft()

1.4 查找最大或最小的 N 个元素
q：从一个集合中获得最大或者最小的 N 个元素列表。
运用heapq 模块有两个函数：nlargest() 和 nsmallest() 
portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])#参数"3"代表N，"portfolio"代表列表，接受参数key，用于dict或其他数据结构类型使用
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])

heap.heapify(list)可以转换列表成为堆结构。堆数据结构最重要的特征是heap[0]永远是最小的元素。剩余的元素可以很容易的通过调用 heapq.heappop() 方法得到， 
该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 O(log N)，N 是堆大小）。 
比如，如果想要查找最小的 3 个元素，heapq.heappop(heap)使用3次。

找最大最小值方法总结：
1.当要查找的元素个数相对比较小的时候，函数 nlargest() 和 nsmallest() 是很合适的
2.仅想查找唯一的最小或最大（N=1）的元素的话，那么使用 min() 和 max() 函数会更快些
3.如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点( sorted(items)[:N] 或者是 sorted(items)[-N:] )

1.5 实现一个优先级队列
#定义类，class后面可加可不加()，如果继承类的时候，一定要加括号并填父类名。
import heapq
class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0
    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item)) #括号里括的是元祖！heappush(heap,item)往堆里添加新值，"heap"是堆，"item"为新值
        self._index += 1 #改变__init()__中的index的大小
    def pop(self):
        return heapq.heappop(self._queue)[-1] #索引为最后位置处的值
class Item:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'Item({!r})'.format(self.name) #format()方法格式化指定的值，并将其插入字符串的占位符内。
q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)
q.pop()
q.pop()
q.pop()
q.pop()

1.6 字典中的键映射多个值
q：实现一个键对应多个值的字典（一键多值字典[multidict]）
d = {
    'a' : [1, 2, 3],
    'b' : [4, 5]
}
e = {
    'a' : {1, 2, 3},
    'b' : {4, 5}
}
或是使用collections模块中的defaultdict来构造这样的字典。
defaultdict的一个特征是它会自动初始化每个key刚开始对应的值，所以只需要关注添加元素操作。
from collections import defaultdict
d = defaultdict(list)#列表
d['a'].append(1)
d['a'].append(2)
d['b'].append(4)
d = defaultdict(set)#集合
d['a'].add(1)
d['a'].add(2)
d['b'].add(4)

一般来讲，创建一个多值映射字典是很简单的。但是，如果你选择自己实现的话，那么对于值的初始化可能会有点麻烦， 你可能会像下面这样来实现：
d = {}
for key, value in pairs:
    if key not in d:
        d[key] = []
    d[key].append(value)
如果使用 defaultdict 的话代码就更加简洁了：
d = defaultdict(list)
for key, value in pairs:
    d[key].append(value)

