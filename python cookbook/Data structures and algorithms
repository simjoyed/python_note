1.1 将序列分解为单独的变量
q：现在有一个包含 N 个元素的元组或者是序列，将它分解为 N 个变量。
运用赋值。不仅仅只是元组或列表，只要对象是可迭代的，就可以执行分解操作。 包括字符串，文件对象，迭代器和生成器。
只想解压一部分，丢弃其他的值。可以使用任意变量名去占位，到时候丢掉这些变量就行了。最多使用，_
>>> data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
>>> _, shares, price, _ = data
>>> shares
50
>>> price
91.1
>>>

1.2 解压可迭代对象赋值给多个变量
q：从任意可迭代对象中解压出 N 个元素出来（可迭代对象的元素个数超过N）。
运用“*表达式”。
星号表达式在迭代元素为可变长元组的序列时是很有用的，如下例所示：
#records是一个
records = [
    ('foo', 1, 2),
    ('bar', 'hello'),
    ('foo', 3, 4),
]
#定义函数
def do_foo(x, y):
    print('foo', x, y)
def do_bar(s):
    print('bar', s)
#注意这里的tag, *args分别代表什么
for tag, *args in records:
    if tag == 'foo':
        do_foo(*args)
    elif tag == 'bar':
        do_bar(*args)

1.3 保留最后 N 个元素
q：在迭代操作或者其他操作的时候，只保留最后有限几个元素的历史记录。
#从collections模块导入deque
from collections import deque
#定义函数，注意这里deque和yield
def search(lines, pattern, history=5):
    previous_lines = deque(maxlen=history)#deque(maxlen=N)创建了一个固定长度的队列，当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。
    for line in lines:
        if pattern in line:
            yield line, previous_lines#yield类似于return，返回一个值，并记住这个返回的位置，下次迭代就从这个位置开始。函数有了yield语句就会转变成一个生成器。
        previous_lines.append(line)
# Example use on a file
if __name__ == '__main__':#__name__是当前模块名，当模块被直接运行时模块名为 __main__ 。 当模块被直接运行时，if 以下代码块将被运行，当模块是被导入时，代码块不被运行。
    with open(r'../../cookbook/somefile.txt') as f:
        for line, prevlines in search(f, 'python', 5):
            for pline in prevlines:
                print(pline, end='')
            print(line, end='')
            print('-' * 20)

如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。
q = deque()
q.append(1)
q.appendleft(4)
q.pop()
q.popleft()












