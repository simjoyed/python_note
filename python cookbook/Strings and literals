2.1 针对任意多的分隔符拆分字符串
q：将一个字符串分割为多个字段，但是分隔符(以及分隔符之间的空格)并不是固定的。
使用正则表达式模块re的split()方法。re.split()
>>> line = 'asdf fjdk; afed, fjek,asdf, foo'
>>> import re
>>> re.split(r'[;,\s]\s*', line) #r'':字符串加r''，防止字符串转义；[]：两个以上的切割符要放在[]里；\s：包含不看见的符，即空格、制表符、换页符；\s*：不知道什么意思
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']

使用re.split()时，注意则表达式中是否包含一个括号捕获分组，如果使用了捕获分组，那么被匹配的文本也将出现在结果列表中。
>>> fields = re.split(r'(;|,|\s)\s*', line)
>>> fields
['asdf', ' ', 'fjdk', ';', 'afed', ',', 'fjek', ',', 'asdf', ',', 'foo']
>>>

>>> values = fields[::2] #从头到尾，奇数位置的值
>>> delimiters = fields[1::2] + [''] #从第二个到尾，偶数位置的值
>>> values
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
>>> delimiters
[' ', ';', ',', ',', ',', '']
>>> # Reform the line using the same delimiters 使用相同的分隔符修改行
>>> ''.join(v+d for v,d in zip(values, delimiters)) #str.join(item)，join函数是一个字符串操作函数。zip()函数将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。
'asdf fjdk;afed,fjek,asdf,foo'
>>>

若不想保留分隔符，以(?:...)形式指定。
>>> re.split(r'(?:,|;|\s)\s*', line)
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
>>>

2.2 字符串开头或结尾做文本匹配
q：通过指定的文本模式去检查字符串的开头或者结尾，比如文件名后缀，URL Scheme等。
使用str.startswith() 或者是 str.endswith() 方法，返回True或False
>>> filename = 'spam.txt'
>>> filename.endswith('.txt')
True
>>> filename.startswith('file:')
False
>>> url = 'http://www.python.org'
>>> url.startswith('http:')
True
>>>

如果针对多个选项做检查，只需要将所有的匹配项放入到一个元组中去， 然后传给 startswith() 或者 endswith() 方法：
>>> import os
>>> filenames = os.listdir('.') #os.listdir()方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。
>>> filenames
[ 'Makefile', 'foo.c', 'bar.py', 'spam.c', 'spam.h' ]
>>> [name for name in filenames if name.endswith(('.c', '.h')) ] #找到以'.c', '.h'结尾的文件名
['foo.c', 'spam.c', 'spam.h']
>>> any(name.endswith('.py') for name in filenames) #any() 函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True。
True #这里结果为True，因为for name in filenames循环了5次，包含'bar.py'
>>>

例子二：
from urllib.request import urlopen #urlopen通过网址URL来获取数据
def read_data(name):
    if name.startswith(('http:', 'https:', 'ftp:')):
        return urlopen(name).read() #网页数据使用urlopen
    else:
        with open(name) as f:
            return f.read() #其余的直接读取

奇怪的是，这个方法中必须要输入一个元组作为参数。如果你恰巧有一个list或者set类型的选择项，要确保传递参数前先调用tuple()将其转换为元组类型。比如：
>>> choices = ['http:', 'ftp:']
>>> url = 'http://www.python.org'
>>> url.startswith(choices)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: startswith first arg must be str or a tuple of str, not list
>>> url.startswith(tuple(choices)) #转换成元组
True
>>>

startswith()和endswith()方法也可以通过使用切片来达到同样的效果：
>>> filename = 'spam.txt'
>>> filename[-4:] == '.txt' #倒数四个字符是否等于'.txt'
True
>>> url = 'http://www.python.org'
>>> url[:5] == 'http:' or url[:6] == 'https:' or url[:4] == 'ftp:'
True
>>>

正则表达式也可作为替代方案：（一般不常用,对于简单的匹配有点大材小用了）
>>> import re
>>> url = 'http://www.python.org'
>>> re.match('http:|https:|ftp:', url) 
<_sre.SRE_Match object at 0x101253098>
>>>

当startswith()和endswith()方法与其他操作相结合的时候效果很不错。比如，下面这个语句检查某个文件夹中是否存在指定的文件类型：
if any(name.endswith(('.c', '.h')) for name in listdir(dirname)):
...

2.3 用Shell通配符做字符串匹配
q：使用Unix Shell中常用的通配符(比如 *.py , Dat[0-9]*.csv 等)去匹配文本字符串
使用fnmatch模块下的两个函数——fnmatch()和fnmatchcase()可以实现这样的匹配。
>>> from fnmatch import fnmatch, fnmatchcase
>>> fnmatch('foo.txt', '*.txt')
True
>>> fnmatch('foo.txt', '?oo.txt')
True
>>> fnmatch('Dat45.csv', 'Dat[0-9]*')
True
>>> names = ['Dat1.csv', 'Dat2.csv', 'config.ini', 'foo.py']
>>> [name for name in names if fnmatch(name, 'Dat*.csv')]
['Dat1.csv', 'Dat2.csv']
>>>

fnmatchcase()完全根据提供的大小写方式匹配。比如：
>>> fnmatchcase('foo.txt', '*.TXT')
False
>>>

在处理非文件名的字符串时也是很有用的：
addresses = [
    '5412 N CLARK ST',
    '1060 W ADDISON ST',
    '1039 W GRANVILLE AVE',
    '2122 N CLARK ST',
    '4802 N BROADWAY',
]
可写如下列表推导式：
>>> from fnmatch import fnmatchcase
>>> [addr for addr in addresses if fnmatchcase(addr, '* ST')]
['5412 N CLARK ST', '1060 W ADDISON ST', '2122 N CLARK ST']
>>> [addr for addr in addresses if fnmatchcase(addr, '54[0-9][0-9] *CLARK*')]
['5412 N CLARK ST']
>>>

fnmatch()函数匹配能力介于简单的字符串方法和强大的正则表达式之间。如果需要做文件名的匹配，最好使用glob模块。参考5.13小节。

2.4 字符串匹配和搜索
q：匹配或者搜索特定模式的文本。
如果只是匹配简单的文字，只需要调用基本字符串方法，如str.find() , str.endswith() , str.startswith()
>>> text = 'yeah, but no, but yeah, but no, but yeah'
>>> # Exact match
>>> text == 'yeah'
False
>>> # Match at start or end
>>> text.startswith('yeah')
True
>>> text.endswith('no')
False
>>> # Search for the location of the first occurrence 搜索第一个出现的位置
>>> text.find('no')
10
>>>

对于复杂的匹配需要使用正则表达式和 re 模块。
如匹配数字格式的日期字符串比如 11/27/2012 ：
>>> text1 = '11/27/2012'
>>> text2 = 'Nov 27, 2012'
>>>
>>> import re
>>> # Simple matching: \d+：表示匹配一个或多个数字
>>> if re.match(r'\d+/\d+/\d+', text1): #类似于占位符\d + / \d + / \d +
... print('yes')
... else:
... print('no')
...
yes
>>> if re.match(r'\d+/\d+/\d+', text2):
... print('yes')
... else:
... print('no')
...
no
>>>

若对同一种模式做多次匹配，使用compile()将正则表达式预编译成一个模式对象。compile：编译
>>> datepat = re.compile(r'\d+/\d+/\d+') #预编译成一个模式对象
>>> if datepat.match(text1):
... print('yes')
... else:
... print('no')
...
yes
>>> if datepat.match(text2):
... print('yes')
... else:
... print('no')
...
no
>>>

match()总是从字符串开始去匹配，若针对整个文本搜索出所有的匹配项，使用 findall() 方法去代替。
>>> text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> datepat.findall(text)
['11/27/2012', '3/13/2013']
>>>

在定义正则式时，常会将部分模式用括号包起来以引入捕获组。
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
>>>

引入捕获组通常能简化后续对匹配文本的处理，因为可以分别将每个组的内容提取出来。
>>> m = datepat.match('11/27/2012')
>>> m
<_sre.SRE_Match object at 0x1005d2750>
>>> # Extract the contents of each group
>>> m.group(0) #group()：分组函数，group（0）就是匹配正则表达式整体结果
'11/27/2012'
>>> m.group(1) #group（1）列出第一个括号匹配部分
'11'
>>> m.group(2)
'27'
>>> m.group(3)
'2012'
>>> m.groups()
('11', '27', '2012')
>>> month, day, year = m.groups()
>>>

>>> # Find all matches (notice splitting into tuples)
>>> text
'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> datepat.findall(text)
[('11', '27', '2012'), ('3', '13', '2013')]
>>> for month, day, year in datepat.findall(text):
... print('{}-{}-{}'.format(year, month, day)) #str.format()格式化函数
...
2012-11-27
2013-3-13
>>>

findall()方法会搜索文本并以列表形式返回所有的匹配。若想以迭代方式（不以列表形式）返回匹配，可以使用 finditer() 方法来代替。
>>> for m in datepat.finditer(text):
... print(m.groups())
...
('11', '27', '2012')
('3', '13', '2013')
>>>

注意：match() 方法仅仅检查字符串的开始部分。它的匹配结果有可能并不是期望的那样。
>>> m = datepat.match('11/27/2012abcdef')
>>> m
<_sre.SRE_Match object at 0x1005d27e8>
>>> m.group()
'11/27/2012'
>>>

若想精确匹配，确保正则表达式以$结尾：
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)$')
>>> datepat.match('11/27/2012abcdef')
>>> datepat.match('11/27/2012')
<_sre.SRE_Match object at 0x1005d2750>
>>>

2.5 字符串搜索和替换
q：在字符串中搜索和匹配指定的文本模式
简单的字面模式，直接使用 str.replace() 方法即可
>>> text = 'yeah, but no, but yeah, but no, but yeah'
>>> text.replace('yeah', 'yep')
'yep, but no, but yep, but no, but yep'
>>>

对于复杂的模式，使用 re 模块中的 sub() 函数。
假设你想将形式为 11/27/2012 的日期字符串改成 2012-11-27 。
>>> text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> import re
>>> re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2', text)
'Today is 2012-11-27. PyCon starts 2013-3-13.'
>>>
sub() 函数中的第一个参数是被匹配的模式，第二个参数是替换模式。反斜杠数字比如 \3 指向前面模式的捕获组号。

做多次替换，则使用模式编译。
>>> import re
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)') #构造模式
>>> datepat.sub(r'\3-\1-\2', text)
'Today is 2012-11-27. PyCon starts 2013-3-13.'
>>>

更加复杂的替换，可以传递一个替换回调函数来代替。
>>> from calendar import month_abbr
>>> def change_date(m):
... mon_name = month_abbr[int(m.group(1))] #使用group()方法来提取特定的匹配部分。
... return '{} {} {}'.format(m.group(2), mon_name, m.group(3))  #回调函数最后返回替换字符串。
...
>>> datepat.sub(change_date, text) #第一个参数为函数，将整个函数作为替换模式
'Today is 27 Nov 2012. PyCon starts 13 Mar 2013.'
>>>
回调函数：简单来说就是定义一个函数，然后将这个函数的函数名传递给另一个函数做参数，以这个参数命名的函数就是回调函数。
一个替换回调函数的参数是一个 match 对象，也就是 match() 或者 find() 返回的对象。

若想知道被替换的个数，可以使用re.subn()代替re.sub()。
>>> newtext, n = datepat.subn(r'\3-\1-\2', text)
>>> newtext
'Today is 2012-11-27. PyCon starts 2013-3-13.'
>>> n
2
>>>

2.6 字符串忽略大小写的搜索替换
q：以忽略大小写的方式搜索与替换文本字符串
在使用 re 模块的时候给这些操作提供 re.IGNORECASE 标志参数。 #IGNORECASE，ignore case：忽略大小写
>>> text = 'UPPER PYTHON, lower python, Mixed Python'
>>> re.findall('python', text, flags=re.IGNORECASE) #添加flags=re.IGNORECASE
['PYTHON', 'python', 'Python']
>>> re.sub('python', 'snake', text, flags=re.IGNORECASE)
'UPPER snake, lower snake, Mixed snake'
>>>

上述的第二个例子揭示出一种局限，替换字符串并不会自动跟被匹配字符串的大小写保持一致。
为了修正这个，需要一个支撑函数（support function）
def matchcase(word): #找到匹配的大小写
    def replace(m): #函数里面嵌套一个函数，且也有形参
        text = m.group()
        if text.isupper(): #整个大写
            return word.upper()
        elif text.islower(): #整个小写
            return word.lower()
        elif text[0].isupper(): #首字母大写
            return word.capitalize()
        else:
            return word
    return replace

下面是使用上述函数的例子：
>>> re.sub('python', matchcase('snake'), text, flags=re.IGNORECASE)
'UPPER SNAKE, lower snake, Mixed Snake'
>>>

对于一般的忽略大小写的匹配操作，简单的传递一个re.IGNORECASE标志参数就足够了。
对于某些需要大小写转换的Unicode匹配可能还不够，详细见2.10小节。

2.7 定义实现最短匹配的正则表达式
q：正在试着用正则表达式匹配某个文本模式，但是它找到的是模式的最长可能匹配。而你想修改它变成查找最短的可能匹配。
这个问题一般出现在需要匹配一对分隔符之间的文本的时候(比如引号包含的字符串)。
>>> str_pat = re.compile(r'"(.*)"') #(.)匹配任意字符
>>> text1 = 'Computer says "no."'
>>> str_pat.findall(text1)
['no.']
>>> text2 = 'Computer says "no." Phone says "yes."'
>>> str_pat.findall(text2)
['no." Phone says "yes.']
>>>

这个例子中，模式 r'\"(.*)\"' 的意图是匹配被双引号包含的文本。
但是在正则表达式中*操作符是贪婪模式的，因此匹配操作会查找最长的可能匹配。
为了修正这个问题，可以在模式中的*操作符后面加上?修饰符，这样就使得匹配变成非贪婪模式，从而得到最短的匹配，就像这样：
>>> str_pat = re.compile(r'"(.*?)"')
>>> str_pat.findall(text2)
['no.', 'yes.']
>>>

 通过在 * 或者 + 这样的操作符后面添加一个 ? 可以强制匹配算法改成寻找最短的可能匹配。

2.8 编写多行模式的正则表达式
q：用正则表达式去匹配一大块的文本，需要跨越多行去匹配。
比如，假设你想试着去匹配C语言分割的注释：
>>> comment = re.compile(r'/\*(.*?)\*/')
>>> text1 = '/* this is a comment */'
>>> text2 = '''/* this is a
... multiline comment */
... '''
>>>
>>> comment.findall(text1)
[' this is a comment ']
>>> comment.findall(text2) #不支持对换行的支持
[]
>>>

为了修正这个问题，可以修改模式字符串，增加对换行的支持。比如：
>>> comment = re.compile(r'/\*((?:.|\n)*?)\*/')
>>> comment.findall(text2)
[' this is a\n multiline comment ']
>>>
(?:.|\n) 指定了一个非捕获组(也就是它定义了一个仅仅用来做匹配，而不能通过单独捕获或者编号的组)。

方案二：
re.compile()函数可接受一个标志参数叫re.DOTALL，可以让正则表达式中的点(.)匹配包括换行符在内的任意字符。比如：
>>> comment = re.compile(r'/\*(.*?)\*/', re.DOTALL)
>>> comment.findall(text2)
[' this is a\n multiline comment ']
对于简单的情况使用re.DOTALL标记参数工作的很好，但是如果模式非常复杂或者是为了构造字符串令牌（tokenizing）而将多个模式合并起来（2.18节），最好还是定义自己的正则表达式模式。









