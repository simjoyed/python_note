2.1 针对任意多的分隔符拆分字符串
q：将一个字符串分割为多个字段，但是分隔符(以及分隔符之间的空格)并不是固定的。
使用正则表达式模块re的split()方法。re.split()
>>> line = 'asdf fjdk; afed, fjek,asdf, foo'
>>> import re
>>> re.split(r'[;,\s]\s*', line) #r'':字符串加r''，防止字符串转义；[]：两个以上的切割符要放在[]里；\s：包含不看见的符，即空格、制表符、换页符；\s*：不知道什么意思
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']

使用re.split()时，注意则表达式中是否包含一个括号捕获分组，如果使用了捕获分组，那么被匹配的文本也将出现在结果列表中。
>>> fields = re.split(r'(;|,|\s)\s*', line)
>>> fields
['asdf', ' ', 'fjdk', ';', 'afed', ',', 'fjek', ',', 'asdf', ',', 'foo']
>>>

>>> values = fields[::2] #从头到尾，奇数位置的值
>>> delimiters = fields[1::2] + [''] #从第二个到尾，偶数位置的值
>>> values
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
>>> delimiters
[' ', ';', ',', ',', ',', '']
>>> # Reform the line using the same delimiters 使用相同的分隔符修改行
>>> ''.join(v+d for v,d in zip(values, delimiters)) #str.join(item)，join函数是一个字符串操作函数。zip()函数将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。
'asdf fjdk;afed,fjek,asdf,foo'
>>>

若不想保留分隔符，以(?:...)形式指定。
>>> re.split(r'(?:,|;|\s)\s*', line)
['asdf', 'fjdk', 'afed', 'fjek', 'asdf', 'foo']
>>>

2.2 字符串开头或结尾做文本匹配
q：通过指定的文本模式去检查字符串的开头或者结尾，比如文件名后缀，URL Scheme等。
使用str.startswith() 或者是 str.endswith() 方法，返回True或False
>>> filename = 'spam.txt'
>>> filename.endswith('.txt')
True
>>> filename.startswith('file:')
False
>>> url = 'http://www.python.org'
>>> url.startswith('http:')
True
>>>

如果针对多个选项做检查，只需要将所有的匹配项放入到一个元组中去， 然后传给 startswith() 或者 endswith() 方法：
>>> import os
>>> filenames = os.listdir('.') #os.listdir()方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。
>>> filenames
[ 'Makefile', 'foo.c', 'bar.py', 'spam.c', 'spam.h' ]
>>> [name for name in filenames if name.endswith(('.c', '.h')) ] #找到以'.c', '.h'结尾的文件名
['foo.c', 'spam.c', 'spam.h']
>>> any(name.endswith('.py') for name in filenames) #any() 函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True。
True #这里结果为True，因为for name in filenames循环了5次，包含'bar.py'
>>>

例子二：
from urllib.request import urlopen #urlopen通过网址URL来获取数据
def read_data(name):
    if name.startswith(('http:', 'https:', 'ftp:')):
        return urlopen(name).read() #网页数据使用urlopen
    else:
        with open(name) as f:
            return f.read() #其余的直接读取

奇怪的是，这个方法中必须要输入一个元组作为参数。如果你恰巧有一个list或者set类型的选择项，要确保传递参数前先调用tuple()将其转换为元组类型。比如：
>>> choices = ['http:', 'ftp:']
>>> url = 'http://www.python.org'
>>> url.startswith(choices)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: startswith first arg must be str or a tuple of str, not list
>>> url.startswith(tuple(choices)) #转换成元组
True
>>>

startswith()和endswith()方法也可以通过使用切片来达到同样的效果：
>>> filename = 'spam.txt'
>>> filename[-4:] == '.txt' #倒数四个字符是否等于'.txt'
True
>>> url = 'http://www.python.org'
>>> url[:5] == 'http:' or url[:6] == 'https:' or url[:4] == 'ftp:'
True
>>>

正则表达式也可作为替代方案：（一般不常用,对于简单的匹配有点大材小用了）
>>> import re
>>> url = 'http://www.python.org'
>>> re.match('http:|https:|ftp:', url) 
<_sre.SRE_Match object at 0x101253098>
>>>

当startswith()和endswith()方法与其他操作相结合的时候效果很不错。比如，下面这个语句检查某个文件夹中是否存在指定的文件类型：
if any(name.endswith(('.c', '.h')) for name in listdir(dirname)):
...

2.3 用Shell通配符做字符串匹配
q：使用Unix Shell中常用的通配符(比如 *.py , Dat[0-9]*.csv 等)去匹配文本字符串
使用fnmatch模块下的两个函数——fnmatch()和fnmatchcase()可以实现这样的匹配。
>>> from fnmatch import fnmatch, fnmatchcase
>>> fnmatch('foo.txt', '*.txt')
True
>>> fnmatch('foo.txt', '?oo.txt')
True
>>> fnmatch('Dat45.csv', 'Dat[0-9]*')
True
>>> names = ['Dat1.csv', 'Dat2.csv', 'config.ini', 'foo.py']
>>> [name for name in names if fnmatch(name, 'Dat*.csv')]
['Dat1.csv', 'Dat2.csv']
>>>

fnmatchcase()完全根据提供的大小写方式匹配。比如：
>>> fnmatchcase('foo.txt', '*.TXT')
False
>>>

在处理非文件名的字符串时也是很有用的：
addresses = [
    '5412 N CLARK ST',
    '1060 W ADDISON ST',
    '1039 W GRANVILLE AVE',
    '2122 N CLARK ST',
    '4802 N BROADWAY',
]
可写如下列表推导式：
>>> from fnmatch import fnmatchcase
>>> [addr for addr in addresses if fnmatchcase(addr, '* ST')]
['5412 N CLARK ST', '1060 W ADDISON ST', '2122 N CLARK ST']
>>> [addr for addr in addresses if fnmatchcase(addr, '54[0-9][0-9] *CLARK*')]
['5412 N CLARK ST']
>>>

fnmatch()函数匹配能力介于简单的字符串方法和强大的正则表达式之间。如果需要做文件名的匹配，最好使用glob模块。参考5.13小节。

2.4 字符串匹配和搜索
q：匹配或者搜索特定模式的文本。
如果只是匹配简单的文字，只需要调用基本字符串方法，如str.find() , str.endswith() , str.startswith()
>>> text = 'yeah, but no, but yeah, but no, but yeah'
>>> # Exact match
>>> text == 'yeah'
False
>>> # Match at start or end
>>> text.startswith('yeah')
True
>>> text.endswith('no')
False
>>> # Search for the location of the first occurrence 搜索第一个出现的位置
>>> text.find('no')
10
>>>

对于复杂的匹配需要使用正则表达式和 re 模块。
如匹配数字格式的日期字符串比如 11/27/2012 ：
>>> text1 = '11/27/2012'
>>> text2 = 'Nov 27, 2012'
>>>
>>> import re
>>> # Simple matching: \d+：表示匹配一个或多个数字
>>> if re.match(r'\d+/\d+/\d+', text1): #类似于占位符\d + / \d + / \d +
... print('yes')
... else:
... print('no')
...
yes
>>> if re.match(r'\d+/\d+/\d+', text2):
... print('yes')
... else:
... print('no')
...
no
>>>

若对同一种模式做多次匹配，使用compile()将正则表达式预编译成一个模式对象。compile：编译
>>> datepat = re.compile(r'\d+/\d+/\d+') #预编译成一个模式对象
>>> if datepat.match(text1):
... print('yes')
... else:
... print('no')
...
yes
>>> if datepat.match(text2):
... print('yes')
... else:
... print('no')
...
no
>>>

match()总是从字符串开始去匹配，若针对整个文本搜索出所有的匹配项，使用 findall() 方法去代替。
>>> text = 'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> datepat.findall(text)
['11/27/2012', '3/13/2013']
>>>

在定义正则式时，常会将部分模式用括号包起来以引入捕获组。
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)')
>>>

引入捕获组通常能简化后续对匹配文本的处理，因为可以分别将每个组的内容提取出来。
>>> m = datepat.match('11/27/2012')
>>> m
<_sre.SRE_Match object at 0x1005d2750>
>>> # Extract the contents of each group
>>> m.group(0) #group()：分组函数，group（0）就是匹配正则表达式整体结果
'11/27/2012'
>>> m.group(1) #group（1）列出第一个括号匹配部分
'11'
>>> m.group(2)
'27'
>>> m.group(3)
'2012'
>>> m.groups()
('11', '27', '2012')
>>> month, day, year = m.groups()
>>>

>>> # Find all matches (notice splitting into tuples)
>>> text
'Today is 11/27/2012. PyCon starts 3/13/2013.'
>>> datepat.findall(text)
[('11', '27', '2012'), ('3', '13', '2013')]
>>> for month, day, year in datepat.findall(text):
... print('{}-{}-{}'.format(year, month, day)) #str.format()格式化函数
...
2012-11-27
2013-3-13
>>>

findall()方法会搜索文本并以列表形式返回所有的匹配。若想以迭代方式（不以列表形式）返回匹配，可以使用 finditer() 方法来代替。
>>> for m in datepat.finditer(text):
... print(m.groups())
...
('11', '27', '2012')
('3', '13', '2013')
>>>

注意：match() 方法仅仅检查字符串的开始部分。它的匹配结果有可能并不是期望的那样。
>>> m = datepat.match('11/27/2012abcdef')
>>> m
<_sre.SRE_Match object at 0x1005d27e8>
>>> m.group()
'11/27/2012'
>>>

若想精确匹配，确保正则表达式以$结尾：
>>> datepat = re.compile(r'(\d+)/(\d+)/(\d+)$')
>>> datepat.match('11/27/2012abcdef')
>>> datepat.match('11/27/2012')
<_sre.SRE_Match object at 0x1005d2750>
>>>











